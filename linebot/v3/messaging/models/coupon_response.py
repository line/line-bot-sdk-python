# coding: utf-8

"""
    LINE Messaging API

    This document describes LINE Messaging API.  # noqa: E501

    The version of the OpenAPI document: 0.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional
from pydantic.v1 import BaseModel, Field, StrictInt, StrictStr, validator
from linebot.v3.messaging.models.acquisition_condition_response import AcquisitionConditionResponse
from linebot.v3.messaging.models.coupon_reward_response import CouponRewardResponse

class CouponResponse(BaseModel):
    """
    Detailed information about a coupon, including all properties and current status.
    """
    acquisition_condition: Optional[AcquisitionConditionResponse] = Field(None, alias="acquisitionCondition")
    barcode_image_url: Optional[StrictStr] = Field(None, alias="barcodeImageUrl", description="URL of the barcode image associated with the coupon. Used for in-store redemption.")
    coupon_code: Optional[StrictStr] = Field(None, alias="couponCode", description="Unique code to be presented by the user to redeem the coupon.")
    description: Optional[StrictStr] = Field(None, description="Detailed description of the coupon. Displayed to users.")
    end_timestamp: Optional[StrictInt] = Field(None, alias="endTimestamp", description="Coupon expiration time (epoch seconds). Coupon cannot be used after this time.")
    image_url: Optional[StrictStr] = Field(None, alias="imageUrl", description="URL of the main image representing the coupon. Displayed in the coupon list.")
    max_acquire_count: Optional[StrictInt] = Field(None, alias="maxAcquireCount", description="Maximum number of coupons that can be issued in total.")
    max_use_count_per_ticket: Optional[StrictInt] = Field(None, alias="maxUseCountPerTicket", description="Maximum number of times a single coupon ticket can be used.")
    max_ticket_per_user: Optional[StrictInt] = Field(None, alias="maxTicketPerUser", description="Maximum number of coupon tickets a single user can acquire.")
    start_timestamp: Optional[StrictInt] = Field(None, alias="startTimestamp", description="Coupon start time (epoch seconds). Coupon can be used from this time.")
    title: Optional[StrictStr] = Field(None, description="Title of the coupon. Displayed in the coupon list.")
    usage_condition: Optional[StrictStr] = Field(None, alias="usageCondition", description="Conditions for using the coupon. Shown to users.")
    reward: Optional[CouponRewardResponse] = None
    visibility: Optional[StrictStr] = Field(None, description="Visibility of the coupon. Determines who can see or acquire the coupon.")
    timezone: Optional[StrictStr] = Field(None, description="Timezone for interpreting start and end timestamps.")
    coupon_id: Optional[StrictStr] = Field(None, alias="couponId", description="Unique identifier of the coupon.")
    created_timestamp: Optional[StrictInt] = Field(None, alias="createdTimestamp", description="Created timestamp (seconds) of the coupon.")
    status: Optional[StrictStr] = Field(None, description="Current status of the coupon.")

    __properties = ["acquisitionCondition", "barcodeImageUrl", "couponCode", "description", "endTimestamp", "imageUrl", "maxAcquireCount", "maxUseCountPerTicket", "maxTicketPerUser", "startTimestamp", "title", "usageCondition", "reward", "visibility", "timezone", "couponId", "createdTimestamp", "status"]

    @validator('visibility')
    def visibility_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('UNLISTED', 'PUBLIC', 'PRIVATE'):
            raise ValueError("must be one of enum values ('UNLISTED', 'PUBLIC', 'PRIVATE')")
        return value

    @validator('timezone')
    def timezone_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('ETC_GMT_MINUS_12', 'ETC_GMT_MINUS_11', 'PACIFIC_HONOLULU', 'AMERICA_ANCHORAGE', 'AMERICA_LOS_ANGELES', 'AMERICA_PHOENIX', 'AMERICA_CHICAGO', 'AMERICA_NEW_YORK', 'AMERICA_CARACAS', 'AMERICA_SANTIAGO', 'AMERICA_ST_JOHNS', 'AMERICA_SAO_PAULO', 'ETC_GMT_MINUS_2', 'ATLANTIC_CAPE_VERDE', 'EUROPE_LONDON', 'EUROPE_PARIS', 'EUROPE_ISTANBUL', 'EUROPE_MOSCOW', 'ASIA_TEHRAN', 'ASIA_TBILISI', 'ASIA_KABUL', 'ASIA_TASHKENT', 'ASIA_COLOMBO', 'ASIA_KATHMANDU', 'ASIA_ALMATY', 'ASIA_RANGOON', 'ASIA_BANGKOK', 'ASIA_TAIPEI', 'ASIA_TOKYO', 'AUSTRALIA_DARWIN', 'AUSTRALIA_SYDNEY', 'ASIA_VLADIVOSTOK', 'ETC_GMT_PLUS_12', 'PACIFIC_TONGATAPU'):
            raise ValueError("must be one of enum values ('ETC_GMT_MINUS_12', 'ETC_GMT_MINUS_11', 'PACIFIC_HONOLULU', 'AMERICA_ANCHORAGE', 'AMERICA_LOS_ANGELES', 'AMERICA_PHOENIX', 'AMERICA_CHICAGO', 'AMERICA_NEW_YORK', 'AMERICA_CARACAS', 'AMERICA_SANTIAGO', 'AMERICA_ST_JOHNS', 'AMERICA_SAO_PAULO', 'ETC_GMT_MINUS_2', 'ATLANTIC_CAPE_VERDE', 'EUROPE_LONDON', 'EUROPE_PARIS', 'EUROPE_ISTANBUL', 'EUROPE_MOSCOW', 'ASIA_TEHRAN', 'ASIA_TBILISI', 'ASIA_KABUL', 'ASIA_TASHKENT', 'ASIA_COLOMBO', 'ASIA_KATHMANDU', 'ASIA_ALMATY', 'ASIA_RANGOON', 'ASIA_BANGKOK', 'ASIA_TAIPEI', 'ASIA_TOKYO', 'AUSTRALIA_DARWIN', 'AUSTRALIA_SYDNEY', 'ASIA_VLADIVOSTOK', 'ETC_GMT_PLUS_12', 'PACIFIC_TONGATAPU')")
        return value

    @validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('DRAFT', 'RUNNING', 'CLOSED'):
            raise ValueError("must be one of enum values ('DRAFT', 'RUNNING', 'CLOSED')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> CouponResponse:
        """Create an instance of CouponResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic.v1 by calling `to_dict()` of acquisition_condition
        if self.acquisition_condition:
            _dict['acquisitionCondition'] = self.acquisition_condition.to_dict()
        # override the default output from pydantic.v1 by calling `to_dict()` of reward
        if self.reward:
            _dict['reward'] = self.reward.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> CouponResponse:
        """Create an instance of CouponResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return CouponResponse.parse_obj(obj)

        _obj = CouponResponse.parse_obj({
            "acquisition_condition": AcquisitionConditionResponse.from_dict(obj.get("acquisitionCondition")) if obj.get("acquisitionCondition") is not None else None,
            "barcode_image_url": obj.get("barcodeImageUrl"),
            "coupon_code": obj.get("couponCode"),
            "description": obj.get("description"),
            "end_timestamp": obj.get("endTimestamp"),
            "image_url": obj.get("imageUrl"),
            "max_acquire_count": obj.get("maxAcquireCount"),
            "max_use_count_per_ticket": obj.get("maxUseCountPerTicket"),
            "max_ticket_per_user": obj.get("maxTicketPerUser"),
            "start_timestamp": obj.get("startTimestamp"),
            "title": obj.get("title"),
            "usage_condition": obj.get("usageCondition"),
            "reward": CouponRewardResponse.from_dict(obj.get("reward")) if obj.get("reward") is not None else None,
            "visibility": obj.get("visibility"),
            "timezone": obj.get("timezone"),
            "coupon_id": obj.get("couponId"),
            "created_timestamp": obj.get("createdTimestamp"),
            "status": obj.get("status")
        })
        return _obj

