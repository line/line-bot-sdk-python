# coding: utf-8

"""
    LINE Messaging API

    This document describes LINE Messaging API.  # noqa: E501

    The version of the OpenAPI document: 0.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional
from pydantic.v1 import BaseModel, Field, StrictInt, StrictStr, conint, constr, validator
from linebot.v3.messaging.models.acquisition_condition_request import AcquisitionConditionRequest
from linebot.v3.messaging.models.coupon_reward_request import CouponRewardRequest

class CouponCreateRequest(BaseModel):
    """
    Request object for creating a coupon. Contains all configurable coupon properties.
    """
    acquisition_condition: AcquisitionConditionRequest = Field(..., alias="acquisitionCondition")
    barcode_image_url: Optional[StrictStr] = Field(None, alias="barcodeImageUrl", description="URL of the barcode image associated with the coupon. Used for in-store redemption.")
    coupon_code: Optional[StrictStr] = Field(None, alias="couponCode", description="Unique code to be presented by the user to redeem the coupon. Optional.")
    description: Optional[constr(strict=True, max_length=1000, min_length=0)] = Field(None, description="Detailed description of the coupon. Displayed to users.")
    end_timestamp: StrictInt = Field(..., alias="endTimestamp", description="Coupon expiration time (epoch seconds). Coupon cannot be used after this time.")
    image_url: Optional[StrictStr] = Field(None, alias="imageUrl", description="URL of the main image representing the coupon. Displayed in the coupon list.")
    max_use_count_per_ticket: conint(strict=True, le=1) = Field(..., alias="maxUseCountPerTicket", description="Maximum number of times a single coupon ticket can be used. Use -1 to indicate no limit.")
    start_timestamp: StrictInt = Field(..., alias="startTimestamp", description="Coupon start time (epoch seconds). Coupon can be used from this time.")
    title: constr(strict=True, max_length=60, min_length=1) = Field(..., description="Title of the coupon. Displayed in the coupon list.")
    usage_condition: Optional[constr(strict=True, max_length=100, min_length=0)] = Field(None, alias="usageCondition", description="Conditions for using the coupon. Shown to users.")
    reward: Optional[CouponRewardRequest] = None
    visibility: StrictStr = Field(..., description="Visibility of the coupon. Determines who can see or acquire the coupon.")
    timezone: StrictStr = Field(..., description="Timezone for interpreting start and end timestamps.")

    __properties = ["acquisitionCondition", "barcodeImageUrl", "couponCode", "description", "endTimestamp", "imageUrl", "maxUseCountPerTicket", "startTimestamp", "title", "usageCondition", "reward", "visibility", "timezone"]

    @validator('visibility')
    def visibility_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('UNLISTED', 'PUBLIC'):
            raise ValueError("must be one of enum values ('UNLISTED', 'PUBLIC')")
        return value

    @validator('timezone')
    def timezone_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('ETC_GMT_MINUS_12', 'ETC_GMT_MINUS_11', 'PACIFIC_HONOLULU', 'AMERICA_ANCHORAGE', 'AMERICA_LOS_ANGELES', 'AMERICA_PHOENIX', 'AMERICA_CHICAGO', 'AMERICA_NEW_YORK', 'AMERICA_CARACAS', 'AMERICA_SANTIAGO', 'AMERICA_ST_JOHNS', 'AMERICA_SAO_PAULO', 'ETC_GMT_MINUS_2', 'ATLANTIC_CAPE_VERDE', 'EUROPE_LONDON', 'EUROPE_PARIS', 'EUROPE_ISTANBUL', 'EUROPE_MOSCOW', 'ASIA_TEHRAN', 'ASIA_TBILISI', 'ASIA_KABUL', 'ASIA_TASHKENT', 'ASIA_COLOMBO', 'ASIA_KATHMANDU', 'ASIA_ALMATY', 'ASIA_RANGOON', 'ASIA_BANGKOK', 'ASIA_TAIPEI', 'ASIA_TOKYO', 'AUSTRALIA_DARWIN', 'AUSTRALIA_SYDNEY', 'ASIA_VLADIVOSTOK', 'ETC_GMT_PLUS_12', 'PACIFIC_TONGATAPU'):
            raise ValueError("must be one of enum values ('ETC_GMT_MINUS_12', 'ETC_GMT_MINUS_11', 'PACIFIC_HONOLULU', 'AMERICA_ANCHORAGE', 'AMERICA_LOS_ANGELES', 'AMERICA_PHOENIX', 'AMERICA_CHICAGO', 'AMERICA_NEW_YORK', 'AMERICA_CARACAS', 'AMERICA_SANTIAGO', 'AMERICA_ST_JOHNS', 'AMERICA_SAO_PAULO', 'ETC_GMT_MINUS_2', 'ATLANTIC_CAPE_VERDE', 'EUROPE_LONDON', 'EUROPE_PARIS', 'EUROPE_ISTANBUL', 'EUROPE_MOSCOW', 'ASIA_TEHRAN', 'ASIA_TBILISI', 'ASIA_KABUL', 'ASIA_TASHKENT', 'ASIA_COLOMBO', 'ASIA_KATHMANDU', 'ASIA_ALMATY', 'ASIA_RANGOON', 'ASIA_BANGKOK', 'ASIA_TAIPEI', 'ASIA_TOKYO', 'AUSTRALIA_DARWIN', 'AUSTRALIA_SYDNEY', 'ASIA_VLADIVOSTOK', 'ETC_GMT_PLUS_12', 'PACIFIC_TONGATAPU')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> CouponCreateRequest:
        """Create an instance of CouponCreateRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic.v1 by calling `to_dict()` of acquisition_condition
        if self.acquisition_condition:
            _dict['acquisitionCondition'] = self.acquisition_condition.to_dict()
        # override the default output from pydantic.v1 by calling `to_dict()` of reward
        if self.reward:
            _dict['reward'] = self.reward.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> CouponCreateRequest:
        """Create an instance of CouponCreateRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return CouponCreateRequest.parse_obj(obj)

        _obj = CouponCreateRequest.parse_obj({
            "acquisition_condition": AcquisitionConditionRequest.from_dict(obj.get("acquisitionCondition")) if obj.get("acquisitionCondition") is not None else None,
            "barcode_image_url": obj.get("barcodeImageUrl"),
            "coupon_code": obj.get("couponCode"),
            "description": obj.get("description"),
            "end_timestamp": obj.get("endTimestamp"),
            "image_url": obj.get("imageUrl"),
            "max_use_count_per_ticket": obj.get("maxUseCountPerTicket"),
            "start_timestamp": obj.get("startTimestamp"),
            "title": obj.get("title"),
            "usage_condition": obj.get("usageCondition"),
            "reward": CouponRewardRequest.from_dict(obj.get("reward")) if obj.get("reward") is not None else None,
            "visibility": obj.get("visibility"),
            "timezone": obj.get("timezone")
        })
        return _obj

